<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Python 并行计算 | GWmodel-Lab</title>
<meta name="description" content="地理加权建模实验室">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://gwmodel-lab.github.io//favicon.ico?v=1556333848619">
<link rel="stylesheet" href="https://gwmodel-lab.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://gwmodel-lab.github.io/">
        <img src="https://gwmodel-lab.github.io//images/avatar.png?v=1556333848619" class="site-logo">
        <h1 class="site-title">GWmodel-Lab</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      地理加权建模实验室
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Python 并行计算</h2>
            <div class="post-date">2019-04-27</div>
            
            <div class="post-content">
              <p>Python 在处理大数据的时候，启用多进程是有效提高计算效率的手段。
Python 已经提供了非常好用的 multiprocess 包来支持多进程编程，
但是在多进程编程时仍然会遇到一些难以处理的问题，需要一些技巧来解决。</p>
<!-- more -->
<p>目录：</p>
<ul>
<li><a href="#python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%95%88%E7%8E%87%E7%9A%84%E6%8F%90%E5%8D%87">Python 多进程对效率的提升</a></li>
<li><a href="#python-%E5%BC%80%E5%90%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B">Python 开启多进程</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA-process-%E5%AF%B9%E8%B1%A1">创建 Process 对象</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0">构造参数</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7">属性</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B">调用示例</a></li>
</ul>
</li>
<li><a href="#%E5%B0%86%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%E4%B8%BA%E7%B1%BB">将进程定义为类</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0pool">进程池（Pool）</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0">进程池构造</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E6%96%B9%E6%B3%95">进程池方法</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B">进程池调用示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90">多进程共享资源</a>
<ul>
<li><a href="#%E9%94%81">锁</a>
<ul>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81lock">互斥锁（Lock）</a></li>
<li><a href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81rlock">可重入锁（RLock）</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E9%94%81condition">条件锁（Condition)</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore">信号量（Semaphore）</a></li>
</ul>
</li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">共享变量</a>
<ul>
<li><a href="#multiprocess-%E5%8C%85%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">multiprocess 包内置类型</a></li>
<li><a href="#%E9%80%9A%E8%BF%87-manager-%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">通过 Manager 创建共享变量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87%E4%BA%8B%E4%BB%B6event%E9%80%9A%E4%BF%A1">通过事件（Event）通信</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E9%98%9F%E5%88%97queue%E9%80%9A%E4%BF%A1">通过队列（Queue）通信</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93pipe%E9%80%9A%E4%BF%A1">通过管道（Pipe）通信</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a>
<ul>
<li><a href="#tqdm-%E5%A4%9A%E8%BF%9B%E5%BA%A6%E6%9D%A1">tqdm 多进度条</a></li>
<li><a href="#windows-%E4%B8%8A-lock-%E7%9A%84%E9%97%AE%E9%A2%98">Windows 上 Lock 的问题</a></li>
</ul>
</li>
</ul>
<h1 id="python-多进程对效率的提升">Python 多进程对效率的提升</h1>
<p>一篇<a href="https://segmentfault.com/a/1190000007495352">《Python 中单线程、多线程和多进程的效率对比实验》</a>的文章中提到：</p>
<blockquote>
<p>Python是运行在解释器中的语言，有一个全局锁（GIL），
在使用多进程(Thread)的情况下，不能发挥多核的优势。
而使用多进程(Multiprocess)，则可以发挥多核的优势真正地提高效率。</p>
</blockquote>
<p>文章中对 Python 在多线程、多进程的效率进行了对比：</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th style="text-align:right">CPU 密集型</th>
<th style="text-align:right">IO 密集型</th>
<th style="text-align:right">网络请求密集型</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性操作</td>
<td style="text-align:right">94.91824996469</td>
<td style="text-align:right">22.46199995279</td>
<td style="text-align:right">7.3296000004</td>
</tr>
<tr>
<td>多线程操作</td>
<td style="text-align:right">101.1700000762</td>
<td style="text-align:right">24.8605000973</td>
<td style="text-align:right">0.5053332647</td>
</tr>
<tr>
<td>多进程操作</td>
<td style="text-align:right">53.8899999857</td>
<td style="text-align:right">12.7840000391</td>
<td style="text-align:right">0.5045000315</td>
</tr>
</tbody>
</table>
<p>可见：</p>
<ol>
<li>多线程操作只在<strong>网络请求密集型</strong>操作中具有非常明显的优势，其开销小于多进程，可用于网络爬虫。</li>
<li>多进程操作在各种操作中都有效率提升，在 IO 密集型操作中的优势更大。</li>
</ol>
<p>最近在处理一套出租车数据，出租车数据量非常大，自己搭建数据库，
查询效率非常低。因此采用 Python 脚本进行处理，</p>
<h1 id="python-开启多进程">Python 开启多进程</h1>
<p>Python 中的 <code>multiprocess</code> 包提供了多进程支持。可以使用三种方法来创建进程。</p>
<h2 id="创建-process-对象">创建 Process 对象</h2>
<p>最简单的开启 Python 进程的方法，是直接构造 <code>multiprocess.Process</code> 对象</p>
<pre><code class="language-python">from multiprocess import Process

process = Process()
</code></pre>
<h3 id="构造参数">构造参数</h3>
<p><code>Process</code> 对象在构造时主要接收三个参数：</p>
<ul>
<li><code>target</code>：进程调用的函数；</li>
<li><code>args</code>：进程调用函数时给函数传递的参数，为一个元组；</li>
<li><code>name</code>：别名。</li>
</ul>
<h3 id="属性">属性</h3>
<p><code>Process</code> 的类型有以下属性：</p>
<ul>
<li><code>daemon</code>：当这个属性设置为 <code>True</code> 时，子进程会随着主进程的结束而结束。否则，主进程结束后，子进程依然会继续进行；</li>
<li><code>exitcode</code>：进程在运行时为 None 、如果为 –N ，表示被信号 N 结束；</li>
<li><code>name</code></li>
<li><code>pid</code></li>
<li><code>authkey</code></li>
</ul>
<h3 id="方法">方法</h3>
<p><code>Process</code> 有如下方法：</p>
<ul>
<li><code>start()</code>：调用 <code>start()</code> 函数时，子进程开始执行，主进程继续执行。</li>
<li><code>join()</code>：“<a href="https://www.cnblogs.com/lipijin/p/3709903.html">阻塞当前进程，直到调用 join 方法的那个进程执行完，再继续执行当前进程。</a>”</li>
<li><code>run()</code>：当构造时如果没有制定 <code>target</code> 参数，那么 <code>start()</code> 方法默认执行 <code>run()</code> 函数。</li>
<li><code>is_alive()</code>：判断当前进程是否活动。</li>
</ul>
<h3 id="调用示例">调用示例</h3>
<pre><code class="language-python">from multiprocess import Process
import os
import math

def work_fun(work_list):
    pass

def distrib_works(work_list, process_num):
    group_length = math.ceil(len(filename_list) / process_num)
    return [work_list[(i*group_length):((i+1)*group_length)] for i in range(process_num)]


work_list = os.listdir(&quot;../data&quot;)
process_num = 4
group = distrib_works(work_list, process_num)

process_list = [Process(target=work_fun, args=(g,)) for g in group_list]
for p in process_list:
    p.daemon = True
    p.start()
for p in process_list:
    p.join()
</code></pre>
<h2 id="将进程定义为类">将进程定义为类</h2>
<p>利用 Python 面向对象的特性，我们可以创建一个类，继承 <code>Process</code> 类，
将一些数据直接在构造的时候保存下来，可以无需在调用的时候传入。
例如，当我们在多进程程序中使用 <code>tqdm</code> 库显示进度条时，会用到其 <code>position</code>
参数来指定当前进度条在控制台中显示的位置，这个参数的值，我们可以直接保存在进程类中，
无需调用的时候再传入。</p>
<p>将进程定义为类的方法如下：</p>
<pre><code class="language-python">from multiprocess import Process

class MyProcess(Process):
    position = 0
    works = None

    def __init__(self, position, works)
        Process.__init__(self)
        self.position = poisition
        self.works = works

    def run():
        pass
</code></pre>
<p>如果在构造函数中，调用的 <code>Process</code> 的构造函数没有指定 <code>target</code>，
进程同样默认执行 <em><strong>不带参数的 <code>run</code> 函数，即使你的 <code>run</code> 函数定义了形参！</strong></em></p>
<p>在创建进程时，只需要将原来调用的 <code>Process</code> 的构造函数，改为调用 <code>MyProcess</code> 的构造函数即可。
这种创建进程方式的实例如下：</p>
<pre><code class="language-python">from multiprocess import Process, Lock

def distrib_works(work_list: List[str], process_num) -&gt; List[List[str]]:
    group_length = math.ceil(len(work_list) / process_num)
    return [g for g in [work_list[(i*group_length):((i+1)*group_length)] for i in range(process_num)] if len(g) &gt; 0]

class FindTargetTaxiProcess(multiprocessing.Process):

    def __init__(self, input_files, index, lock, log_file):
        multiprocessing.Process.__init__(self, target=find_target, args=(lock, log_file))
        self.input_files = input_files
        self.index = index

    def find_target(self, lock, log_file):
        for filename in self.input_files:
            with open(filename) as in_file:
                for row in tqdm(in_file, ncols=80, position=self.index):
                    cells = row.split(&quot;,&quot;)
                    if int(cells[0]) == 11865:
                        print(row)

if __name__ == '__main__':
    LOG_FILE = r&quot;E:\出租车点\上下车点\scripts\data\find_error.log&quot;
    lock = multiprocessing.Lock()
    # ROOT_DIR = &quot;../data/201502/temp&quot;
    ROOT_DIR = r&quot;E:\出租车点\201502\RawCSV&quot;
    INPUT_FILES = [os.path.join(ROOT_DIR, f) for f in os.listdir(ROOT_DIR)]
    GROUP_LIST = distrib_works(INPUT_FILES, 4)
    PROCESS_LIST = [FineTargetTaxiProcess(element, i, lock) for i, element in enumerate(GROUP_LIST)]
    for process in PROCESS_LIST:
        process.start()
</code></pre>
<blockquote>
<p>这种定义为类的方式有一个好处，在用 VSCode 调试的时候，在子进程中打断点是无效的。
如果用这种方式，可以将调用的 <code>start()</code> 函数改为 <code>run()</code> 或其他实际进程执行的函数，
这样就可以调试进程内部了。当解决了 Bug 后，就可以换回 <code>start()</code> 函数并行执行。</p>
</blockquote>
<h2 id="进程池pool">进程池（Pool）</h2>
<p>可以发现，上面两种创建进程的方式，都是用到了一个 <code>distrib_works()</code> 函数来分配各个进程的任务。
这一过程可以被一个叫做进程池的类型代替。</p>
<h3 id="进程池构造">进程池构造</h3>
<p>构造进程池的方法非常简单，导入 <code>Pool</code> 之后，直接构造 <code>Pool</code> 对象。
构造时可以指定最多的进程数量，默认是 CPU 核心数。</p>
<pre><code class="language-python">from multiprocess import Pool

p = Pool(process=6)
</code></pre>
<h3 id="进程池方法">进程池方法</h3>
<p><code>Pool</code> 类型主要有以下方法：</p>
<ul>
<li><code>apply_async()</code> 和 <code>apply()</code>：这两个函数都是让进程池开始执行任务，<code>apply_async()</code> 是非阻塞的（主进程继续执行），<code>apply()</code> 是阻塞的（主进程等待子进程执行完成后继续执行）。</li>
<li><code>close()</code>：关闭进程池，不再接收新任务。</li>
<li><code>join()</code>：<a href="http://www.cnblogs.com/kaituorensheng/p/4445418.html">主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。</a></li>
</ul>
<h3 id="进程池调用示例">进程池调用示例</h3>
<p>将上面一段使用 <code>FindTargetTaxiProcess</code> 类编写的代码用 <code>Pool</code> 重写：</p>
<pre><code class="language-python">from multiprocess import Process, Pool, Lock

def find_target(in_file, lock, log_file):
    with open(filename) as in_file:
        for row in tqdm(in_file, ncols=80, position=self.index):
            cells = row.split(&quot;,&quot;)
            if int(cells[0]) == 11865:
                with lock:
                    with open(log_file, mode=&quot;a&quot;) as log:
                        print(row, file=log)

if __name__ == '__main__':
    LOCK = multiprocessing.Lock()
    LOG_FILE = r&quot;E:\出租车点\上下车点\scripts\data\find_error.log&quot;
    ROOT_DIR = r&quot;E:\出租车点\201502\RawCSV&quot;
    INPUT_FILES = [os.path.join(ROOT_DIR, f) for f in os.listdir(ROOT_DIR)]
    POOL = Pool(process=6)
    for f in INPUT_FILES:
        POOL.apply_async(find_target, (f, LOCK, LOG_FILE))
    POOL.close()
    POOL.join()
</code></pre>
<h1 id="多进程共享资源">多进程共享资源</h1>
<p>当我们把多个任务分解到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 个进程上执行时，这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 个进程往往会存在某种共享的资源，
如共享一个控制台、文件系统、列表或字典。这里存在两个问题：</p>
<ul>
<li>当多个进程同时访问这些资源时，就会产生冲突。例如，两个进程同时对控制台输出文本，写入的结果可以错综复杂，并不是两段文本的顺序组合。</li>
<li>各个进程有自己的内存空间，变量无法共享。例如，当想要利用多个进程操作主进程的一个列表时，各个进程操作结束后，主进程仍然是原来的状态。</li>
</ul>
<p>这两个问题的解决，前者靠“锁”机制，后者靠“共享变量”机制。</p>
<h2 id="锁">锁</h2>
<p>对于冲突的情况，当使用 tqdm 显示多个进度条时比较明显。在 Windows 上，由于
“tqdm 无法获取默认锁”，因此控制台输出会比较乱，下面是一段程序在 Windows 上运行的效果：</p>
<pre><code class="language-markdown">λ python3 find_errors.py
Process 0: 0it [00:00, ?it/s]
Process 1: 0it [00:00, ?it/s]
Process 0: 273516it [00:00, 523719.79it/s]
Process 0: 995883it [00:01, 510379.67it/s]
Process 0: 1107387it [00:02, 510326.10it/s]
Process 0: 1224813it [00:02, 512761.81it/s]
Process 0: 3483799it [00:06, 539191.83it/s]
Process 1: 3683852it [00:06, 571536.15it/s]
Process 0: 3550015it [00:06, 540296.03it/s]
Process 0: 3615558it [00:06, 540947.45it/s]
Process 0: 3742521it [00:06, 542112.37it/s]
</code></pre>
<p>而在 Linux 系统中的运行结果是</p>
<pre><code class="language-markdown">Process 0: 2045720it [00:03, 647073.52it/s]
Process 1: 2092184it [00:03, 661530.01it/s]
Process 2: 2065411it [00:03, 652446.31it/s]
Process 3: 2093610it [00:03, 661782.04it/s]
</code></pre>
<p>可见在访问共享资源的时候，加锁是非常有必要的。</p>
<h3 id="互斥锁lock">互斥锁（Lock）</h3>
<p><code>Lock</code> 属于“互斥锁”，即<a href="https://www.jb51.net/article/63508.htm">保证在任一时刻，只能有一个线程访问该对象。</a>
通过 <code>Lock</code> 类型创建互斥锁后，将其传递到子进程内部，即可在子进程中使用。</p>
<p>使用 <code>Lock</code> 时，可以使用 <code>with</code> 语句加锁， <code>with</code> 语句块执行完成后自动解锁；
也可以通过其 <code>acquire()</code> 函数来加锁，使用 <code>release()</code> 函数解锁。</p>
<p>使用 <code>with</code> 语句进行加锁的示例代码如下：</p>
<pre><code class="language-python">def run(self):
    for filename in self.input_files:
        with open(filename, encoding=&quot;GB2312&quot;) as in_file:
            for row in tqdm(in_file):
                cells = row.split(&quot;,&quot;)
                if int(cells[0]) == 11865:
                    with self.lock:
                        with open(TARGET_TAXI_FILE, mode=&quot;a&quot;) as log:
                            print(row, file=log)
</code></pre>
<blockquote>
<p>这段代码在 Windows 上运行时，子进程内部的 lock 和 主进程传递进去的 lock 的 id 值不相同。
但是在 Linux 系统上时相同的。因此 Windows 上这段代码有可能会出错。
不过当文件被一个进程打开时，是无法被另一个进程打开的，因此这段程序的结果倒没出什么错。</p>
</blockquote>
<h3 id="可重入锁rlock">可重入锁（RLock）</h3>
<p>互斥锁可以解决简单的避免资源冲突的问题，但当一个线程加锁后仍需要再次访问共享资源时，
就形成了嵌套锁，而使用互斥锁时就形成了“死锁”问题。这时我们需要使用 <code>RLock</code> 类型，
即“可重入锁”。</p>
<blockquote>
<p>死锁的含义是：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，
若无外力作用，它们都将无法推进下去。
此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
避免死锁主要方法是正确有序的分配资源。</p>
</blockquote>
<p><code>multiprocess</code> 中的 <code>RLock</code> 类型与 <code>Lock</code> 类型的区别在于：
<a href="https://blog.csdn.net/cnmilan/article/details/8849895">RLock允许在同一线程中被多次申请。而 Lock 却不允许这种情况。</a>
因此，<a href="https://blog.csdn.net/cnmilan/article/details/8849895">如果使用 <code>RLock</code> ，那么 acquire() 和 release() 必须成对出现</a>，
调用了几次 <code>acquire()</code>，就需要调用几次 <code>release()</code>。</p>
<h3 id="条件锁condition">条件锁（Condition)</h3>
<p>条件同步机制是指：线程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> 等待特定条件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> ，而另一个线程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span> 发出特定条件满足的信号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> 。
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> 在收到信号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span> 时，继续执行。</p>
<p>可以通过“生产者-消费者”模型来理解这一过程。
生产者获取锁，生产一个随机整数，通知消费者并释放锁。
消费者获取锁，如果有整数则消耗一个整数并释放锁，如果没有就等待生产者继续生产。</p>
<p>示例代码如下（参考<a href="https://yoyzhou.github.io/blog/2013/02/28/python-threads-synchronization-locks/">《Python 线程同步机制》</a>并进行修改）：</p>
<pre><code class="language-python">import multiprocess


class Producer(multiprocessing.Process):
    def __init__(self, productList, condition):
        multiprocessing.Process.__init__(self)
        self.productList = productList  # type: List
        self.condition = condition  # type: multiprocess.Condition

    def run(self):
        while True:
            product = random.randint(0, 100)
            with self.condition:
                print(&quot;条件锁：被 生产者 获取&quot;)
                self.productList.append(product)
                print(f&quot;生产者：产生了 {product}。&quot;)
                print(&quot;生产者：唤醒消费者线程&quot;)
                self.condition.notify()
                print(&quot;条件锁：被 生产者 释放&quot;)
            time.sleep(1)


class Customer(multiprocessing.Process):

    def __init__(self, productList, condition):
        multiprocessing.Process.__init__(self)
        self.productList = productList  # type: List
        self.condition = condition  # type: multiprocess.Condition

    def run(self):
        while True:
            with self.condition:
                print(&quot;条件锁：被 消费者 获取&quot;)
                while True:
                    if self.productList:
                        product = self.productList.pop()
                        print(f&quot;消费者：消费了 {product}&quot;)
                        break
                    print(&quot;消费者：等待生产者&quot;)
                    self.condition.wait()
                print(&quot;条件锁：被 消费者 释放&quot;)


def main():
    manager = multiprocessing.Manager()
    productList = manager.list()
    condition = multiprocessing.Condition()
    process_producer = Producer(productList, condition)
    process_customer = Customer(productList, condition)
    process_producer.start()
    process_customer.start()
    process_producer.join()
    process_customer.join()

if __name__ == '__main__':
    main()
</code></pre>
<p>运行的部分结果是：</p>
<pre><code class="language-markdown">条件锁：被 生产者 获取
生产者：产生了 47。
生产者：唤醒消费者线程
条件锁：被 生产者 释放
条件锁：被 消费者 获取
消费者：消费了 47
条件锁：被 消费者 释放
条件锁：被 消费者 获取
消费者：等待生产者
条件锁：被 生产者 获取
生产者：产生了 100。
生产者：唤醒消费者线程
条件锁：被 生产者 释放
消费者：消费了 100
条件锁：被 消费者 释放
条件锁：被 消费者 获取
消费者：等待生产者
条件锁：被 生产者 获取
生产者：产生了 95。
生产者：唤醒消费者线程
条件锁：被 生产者 释放
消费者：消费了 95
条件锁：被 消费者 释放
条件锁：被 消费者 获取
消费者：等待生产者
</code></pre>
<h3 id="信号量semaphore">信号量（Semaphore）</h3>
<p>信号量是一个非负整数，所有通过它的进程都会将该整数减一，
当该整数值为零时，所有试图通过它的进程都将处于等待状态。</p>
<pre><code class="language-python">from multiprocessing import Process, current_process, Semaphore
import time

def worker(s, i):
    s.acquire()
    print(current_process().name + &quot;acquire&quot;);
    time.sleep(i)
    print(current_process().name + &quot;release\n&quot;);
    s.release()

if __name__ == &quot;__main__&quot;:
    s = Semaphore(2)
    for i in range(5):
        p = Process(target = worker, args=(s, i*2))
        p.start()
</code></pre>
<h2 id="共享变量">共享变量</h2>
<p>在多进程中，是无法直接使用全局变量作为共享变量的，因为不同进程具有不同的内存空间。
但是，共享变量也是不能避免的。Python 中也提供了一些创建共享变量的方法。</p>
<ul>
<li>Multiprocess 包内置类型</li>
<li>通过 Manager 创建共享变量</li>
</ul>
<h3 id="multiprocess-包内置类型">multiprocess 包内置类型</h3>
<p>multiprocess 包提供了两种类型的共享变量：</p>
<ul>
<li><code>Value(typecode_or_type, *args, lock=True)</code>：表示一个值类型变量。</li>
<li><code>Array(typecode_or_type, size_or_initializer, *, lock=True)</code>：表示一个数组。这种创建数组的方式能力比较有限，它不支持除了 C 数据类型以外的类型。</li>
</ul>
<p><code>typecode_or_type</code> 描述了元素的类型，可取值是：</p>
<table>
<thead>
<tr>
<th>typecode</th>
<th>type</th>
</tr>
</thead>
<tbody>
<tr>
<td>'c'</td>
<td>ctypes.c_char</td>
</tr>
<tr>
<td>'u'</td>
<td>ctypes.c_wchar</td>
</tr>
<tr>
<td>'b'</td>
<td>ctypes.c_byte</td>
</tr>
<tr>
<td>'B'</td>
<td>ctypes.c_ubyte</td>
</tr>
<tr>
<td>'h'</td>
<td>ctypes.c_short</td>
</tr>
<tr>
<td>'H'</td>
<td>ctypes.c_ushort</td>
</tr>
<tr>
<td>'i'</td>
<td>ctypes.c_int</td>
</tr>
<tr>
<td>'I'</td>
<td>ctypes.c_uint</td>
</tr>
<tr>
<td>'l'</td>
<td>ctypes.c_long</td>
</tr>
<tr>
<td>'L'</td>
<td>ctypes.c_ulong</td>
</tr>
<tr>
<td>'f'</td>
<td>ctypes.c_float</td>
</tr>
<tr>
<td>'d'</td>
<td>ctypes.c_doubl</td>
</tr>
</tbody>
</table>
<p>创建后，只要将这些变量传递给子进程即可。</p>
<h3 id="通过-manager-创建共享变量">通过 Manager 创建共享变量</h3>
<p>Manager() 返回的 manager 对象提供一个服务进程，使得其他进程可以通过代理的方式操作 Python 对象。
Manager 支持 list、dict 等多种数据类型。
（<a href="http://www.liujiangblog.com/course/python/82">多进程multiprocess</a>）</p>
<p>把之前的共享变量的代码中，共享的变量由 list 改为 Manager 对象创建的 list，可以得到正确结果。</p>
<pre><code class="language-python">from multiprocessing import Process, Lock, Manager
import time

def work(lock, var, index):
    with lock:
        var.append(index)
        print(f&quot;Process {index} apped {index}&quot;)

if __name__ == '__main__':
    var = Manager().list()
    lock = Lock()
    process_list = [Process(target=work, args=(lock, var, i)) for i in range(8)]
    for p in process_list:
        p.start()
    for p in process_list:
        p.join()
    print(var)
</code></pre>
<h1 id="进程间通信">进程间通信</h1>
<p>进程间通信，可以起到共享变量的效果，也可以起到锁的效果。</p>
<p>进程间通信的方式有三种：</p>
<ul>
<li>事件（Event）</li>
<li>队列（Queue）</li>
<li>管道（Pipe）</li>
</ul>
<h2 id="通过事件event通信">通过事件（Event）通信</h2>
<p>Event 是同步通信的方式，有些类似于条件锁。由于是它是同步的，而且不能传递数据。
因此这里就不仔细研究 Event 的作用。</p>
<p>这个例子示例了主进程与子进程之间通过 Event 进行通信的方法。</p>
<pre><code class="language-python">import multiprocessing
import time
def wait_for_event(e):
    print(&quot;wait_for_event: starting&quot;)
    e.wait()
    print(&quot;wairt_for_event: e.is_set()-&gt;&quot; + str(e.is_set()))

def wait_for_event_timeout(e, t):
    print(&quot;wait_for_event_timeout:starting&quot;)
    e.wait(t)
    print(&quot;wait_for_event_timeout:e.is_set-&gt;&quot; + str(e.is_set()))

if __name__ == &quot;__main__&quot;:
    e = multiprocessing.Event()
    w1 = multiprocessing.Process(target=wait_for_event, args=(e,))
    w2 = multiprocessing.Process(target=wait_for_event_timeout, args=(e, 6))
    w1.start()
    w2.start()
    time.sleep(10)
    print(&quot;main: event setting&quot;)
    e.set()
    print(&quot;main: event is set&quot;)
</code></pre>
<h2 id="通过队列queue通信">通过队列（Queue）通信</h2>
<p>Queue 是多进程安全的队列，可以使用 Queue 实现多进程之间的数据传递。
Queue 有两个方法：</p>
<ul>
<li><code>put()</code>：将数据插入队列中。</li>
<li><code>get()</code>：从队列读取并且删除一个元素。</li>
</ul>
<p>这两个方法都有两个参数：<code>blocked</code>, <code>timeout</code>，
控制队满和队空两种情况：</p>
<ul>
<li><code>put</code>：当队满时，如果 <code>blocked=True</code> ，那么会阻塞 <code>timeout</code> 指定的时间，直到队列有空间。如果超时，或 <code>blocked=False</code> ，则抛出 <code>Queue.Full</code> 异常。</li>
<li><code>get</code>：当队满时，如果 <code>blocked=True</code> ，那么会阻塞 <code>timeout</code> 指定的时间，直到队列有元素。如果超时，或 <code>blocked=False</code> ，则抛出 <code>Queue.Empty</code> 异常。</li>
</ul>
<p>调用实例：</p>
<pre><code class="language-python">class FineTargetTaxiProcess(mp.Process):
    '''
    处理进程：多进程方式处理文件，结果全部传递给打印进程。
    '''
    def __init__(self, input_files, index, queue):
        mp.Process.__init__(self, target=self.pick, args=(queue,))
        self.input_files = input_files
        self.index = index
        self.lock = lock

    def pick(self, queue):
        for filename in tqdm(self.input_files, ncols=80, position=self.index, desc=f&quot;Process {self.index}&quot;):
            with open(filename, encoding=&quot;GB2312&quot;) as in_file:
                for row in in_file:
                    cells = row.split(&quot;,&quot;)
                    if int(cells[0]) == 11865:
                        try:
                            queue.put(&quot;,&quot;.join(cells), block=False)
                        except:
                            print(&quot;Queue full&quot;)

class PrinterProcess(mp.Process):
    '''
    打印进程：维持对输出文件的打开状态，打印数据。
    可避免频繁打开、关闭结果文件造成的系统开销，
    但是引入了消息传递的开销。
    '''
    def __init__(self, output_file, log, queue):
        mp.Process.__init__(self, target=self.write, args=(queue,))
        self.output_file = output_file
        self.log_file = log

    def write(self, queue):
        with open(self.output_file, mode=&quot;w&quot;, newline=&quot;\n&quot;) as printer, open(self.log_file, mode=&quot;w&quot;) as log:
            while True:
                try:
                    row = queue.get(block=True, timeout=1)
                    print(row, file=printer)
                except:
                    print(&quot;Queue empty&quot;, file=log)

if __name__ == '__main__':
    lock = mp.Lock()
    ROOT_DIR = r&quot;/mnt/e/出租车点/201502/RawCSV&quot;
    INPUT_FILES = [os.path.join(ROOT_DIR, f) for f in os.listdir(ROOT_DIR)]
    GROUP_LIST = distrib_works(INPUT_FILES, 6)
    QUEUE = mp.Queue()
    PROCESS_LIST = [FineTargetTaxiProcess(element, i, QUEUE) for i, element in enumerate(GROUP_LIST)]
    PRINTER_PROCESS = PrinterProcess(&quot;./data/usequeue.txt&quot;, &quot;./data/usequeue.log&quot;, QUEUE)
    for process in PROCESS_LIST:
        process.daemon = True
        process.start()
    PRINTER_PROCESS.daemon = True
    PRINTER_PROCESS.start()
    for p in PROCESS_LIST:
        p.join()
</code></pre>
<h2 id="通过管道pipe通信">通过管道（Pipe）通信</h2>
<p>Pipe 是一个可以双向通信的对象，返回 <code>(conn1, conn2)</code>，
代表一个管道的两个端， <code>conn1</code> 只负责接受消息， <code>conn2</code> 只负责发送消息。
如果设置了 <code>duplex=True</code> ，那么这个管道是全双工模式，
<code>conn1</code> 和 <code>conn2</code> 均可收发。</p>
<pre><code class="language-python">class FineTargetTaxiProcess(mp.Process):
    '''
    处理进程：多进程方式处理文件，结果全部传递给打印进程。
    '''
    def __init__(self, input_files, index, pipe):
        mp.Process.__init__(self, target=self.pick, args=(pipe,))
        self.input_files = input_files
        self.index = index
        self.lock = lock

    def pick(self, pipe):
        for filename in tqdm(self.input_files, ncols=80, position=self.index, desc=f&quot;Process {self.index}&quot;):
            with open(filename, encoding=&quot;GB2312&quot;) as in_file:
                for row in in_file:
                    cells = row.split(&quot;,&quot;)
                    if int(cells[0]) == 11865:
                        try:
                            pipe.send(&quot;,&quot;.join(cells))
                        except e as Exception:
                            print(&quot;Pipe send error&quot;)

class PrinterProcess(mp.Process):
    '''
    打印进程：维持对输出文件的打开状态，打印数据。
    可避免频繁打开、关闭结果文件造成的系统开销，
    但是引入了消息传递的开销。
    '''
    def __init__(self, output_file, log, pipe):
        mp.Process.__init__(self, target=self.write, args=(pipe,))
        self.output_file = output_file
        self.log_file = log

    def write(self, pipe):
        with open(self.output_file, mode=&quot;w&quot;, newline=&quot;\n&quot;) as printer, open(self.log_file, mode=&quot;w&quot;) as log:
            while True:
                try:
                    row = pipe.recv()
                    print(row, file=printer)
                except e as Exception:
                    print(&quot;Pipe read error&quot;, file=log)

if __name__ == '__main__':
    lock = mp.Lock()
    # ROOT_DIR = &quot;../data/201502/temp&quot;
    ROOT_DIR = r&quot;/mnt/e/出租车点/201502/RawCSV&quot;
    INPUT_FILES = [os.path.join(ROOT_DIR, f) for f in os.listdir(ROOT_DIR)]
    GROUP_LIST = distrib_works(INPUT_FILES, 6)
    (RECEIVER, SENDER) = mp.Pipe()
    PROCESS_LIST = [FineTargetTaxiProcess(element, i, SENDER) for i, element in enumerate(GROUP_LIST)]
    PRINTER_PROCESS = PrinterProcess(&quot;./data/usepipe.txt&quot;, &quot;./data/usepipe.log&quot;, RECEIVER)
    for process in PROCESS_LIST:
        process.daemon = True
        process.start()
    PRINTER_PROCESS.daemon = True
    PRINTER_PROCESS.start()
    for p in PROCESS_LIST:
        p.join()
</code></pre>
<h1 id="其他">其他</h1>
<h2 id="tqdm-多进度条">tqdm 多进度条</h2>
<p>是一个快速，可扩展的 Python 进度条，可以在 Python 长循环中添加一个进度提示信息，
用户只需要封装任意的迭代器 <code>tqdm(iterator)</code> 。</p>
<p>这里有一些参数：</p>
<ul>
<li><code>ncols</code>：整个进度条（包括条以及其他文字）的宽度。最好设置一个小于控制台总宽的值。</li>
<li><code>mininterval</code>：进度条更新的最小间隔。默认为 0.1。</li>
<li><code>position</code>：进度条的位置，从0开始。对不同的 tqdm 对象设置不同的 position，可以在控制台的不同位置显示出来，适用于多进程与多线程。</li>
</ul>
<blockquote>
<p>由于 Windows 上多进程时 tqdm 无法获取默认的锁，所以会出现进度条错乱。在 Linux 上是没有问题的。</p>
</blockquote>
<h2 id="windows-上-lock-的问题">Windows 上 Lock 的问题</h2>
<p>其实每次传入子进程函数内部的 <code>Lock</code>，在各个进程中的 <code>id</code> 都不一样。在 Linux 下没有这个问题。
这往往会导致一些程序在 Windows 上不正确。
因此，在 Windows 上最好少用 <code>Lock</code>，多采用消息传递或共享变量的方式设计程序。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://gwmodel-lab.github.io//tag/fpoqDY1vf" class="tag">
                    Python
                  </a>
                
              </div>
            
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  
  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '0fa4be717389b11230d5',
        clientSecret: 'aced03db6d00538c3f3e8c1e03aae6cb3ce1abe6',
        repo: 'GWmodel-Lab.github.io',
        owner: 'GWmodel-Lab',
        admin: ['GWmodel-Lab'],
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
